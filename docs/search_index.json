[["index.html", "Data Analysis and Visualization in R (IN2339) A practical introduction to Data Science Preface", " Data Analysis and Visualization in R (IN2339) A practical introduction to Data Science Chair of Computational Molecular Medicine 2021-03-15 Preface This is the lecture script of the module Data Analysis and Visualization in R (IN2339). This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) "],["acknowledgments.html", "Acknowledgments", " Acknowledgments The script has been first put together in 2020 by Felix Brechtmann, Daniela Klaproth-Andrade, Alexander Karollus, Vangelis Theodorakis, Vicente Yepez, Ines Scheller, and Julien Gagneur. We leverage work from colleagues in designing lecture slides since 2017: Žiga Avsec, Ines Assum, Daniel Bader, Jun Cheng, Bašak Eraslan, Mathias Heinig, Jan Krumsieck, Christian Mertes, and Georg Stricker. "],["prerequisites.html", "Prerequisites", " Prerequisites Basics in probabilities are required. Chapters 13-15 (“Introduction to Statistics with R,” “Probability” and “Random variables”) of the Book “Introduction to Data Science” https://rafalab.github.io/dsbook/ make a good refresher. Make sure all concepts are familiar to you. Check your knowledge by trying the exercises. "],["introduction.html", "Introduction Data Science: What and why? What you will learn and not learn The R language Course overview Complementary reading", " Introduction Data Science: What and why? Data science is an interdisciplinary field about processes and systems to extract knowledge or insights from data. The goals of Data Science include discovering new phenomena or trends from data, enabling decisions based on facts derived from data, and communicating findings from data. It is a continuation of some of the data analysis fields such as statistics, data mining, and predictive analytics. Data Science is at the heart of the scientific method, which starts with making data-driven observations to formulate testable hypotheses. It furthermore comes into play to visualize and assess experimental results. Data science skills are therefore necessary to any field of scientific research. Data science is the main tools of epidemiology, the study of health and disease in populations, which largely relies on observational data. Moreover data science is important in the industry, to understand operational process, and in business analytics, to understand a particular market. Hence, with the rise of big data in all areas of society, data science skills are some of the most demanded skills on the job market. Last, but not least, in an era of fake news, data science skills are important for citizens of modern societies. What you will learn and not learn The goal of this course is to allow you to provide you general analytic techniques to extract knowledge, patterns, and connections between samples and variables, and how to communicate these in an intuitive and clear way. This course focuses on front-end data science. This means, it teaches practical skills to analyse data. We will focus on tidy data, visualizations, and data manipulation in R. To only then dive into the math required to understand and interpret analysis results. This course does not teach back-end data science, i.e. it does not teach how to develop your own statistical or machine learning models, nor how to develop scalable data processing software. Other courses offered by the faculty of Informatics cover data science back-end skills. The R language R is a statistical programming language designed for data analytics. It is a great language for front-end data science, i.e. to rapidly manipulate, visualize and come to raising interesting hypotheses. Seen from a software developer point of view (i.e. from a back-end data science point of view), R can be seen cumbersome and not using memory and computing resources efficiently. The purpose of the R language is to reduce time spent in coding to maximize user’s brain time on looking at te data and thinking about it, rather that reducing computer’s running time. Of course, they are ways to develop efficient R software, notably by relying on implementation in lower languages such as C. This course does not cover such R developer skills. Another advantage of R is that it offers a very large set of libraries from many application areas. Course overview The lecture is structured into three main parts covering the major steps of data analysis: Get the data: After basic introduction to R, learn how to fetch and manipulate real-world datasets. How to structure them to most conveniently work with them (tidy data). Look at the data: Basic and advanced visualization techniques allows navigating large and complex datasets, identifying interesting signal, and formulating hypotheses. Typical sources of confounding are discussed. Recommendation to present an analysis in compelling fashion are also given. Conclude: Concepts of hypothesis testing will allow concluding about the statistical robustness of discovered associations. Also, methods from supervised learning will allow to model data and build accurate predictors. The chapters of this script corresponds to individual lectures. Appendices provide further technical details as well as R tricks and tips. Complementary reading These books offer complementary information to this script: Introduction to Data Science, Rafael A. Irizarry [https://rafalab.github.io/dsbook/] R for Data Science, Garrett Grolemund and Hadley Wickham [https://r4ds.had.co.nz/] Statistical Inference via Data Science, Chester Ismay and Albert Y. Kim [https://moderndive.com/] Fundamentals of Data Visualization, Claus O. Wilke [https://clauswilke.com/dataviz/] Advanced R, Hadley Wickham [https://adv-r.hadley.nz/] "],["r-basics.html", "Chapter 1 R basics 1.1 Rstudio 1.2 First steps with R 1.3 Data types 1.4 Vectors 1.5 Coercion 1.6 Sorting 1.7 Vector arithmetics 1.8 Indexing 1.9 R programming", " Chapter 1 R basics This chapter provides a quick introduction to the programming language R and to using the software RStudio. 1.1 Rstudio Rstudio is a software that allows to program in R and interactively analyse data with R. It succinctly organizes your session into 4 panels each set up for you to do certain tasks in each panel: Edit and write code (source panel), run and execute code (console panel), list objects that you have in your environment and have a history of your past commands (environment/history panel), and a panel to show your folders’ structure, see plots, install/load packages, and read the documentation of functions (files/plots/packages/help panel). the main script section, for writing scripts [top left section] (Ctrl+1 to focus) the console tab, for typing R commands directly [bottom left section as tab] (Ctrl+2 to focus) the terminal tab, for direct access to your system shell [bottom left section] (Shift+Alt+T to focus) the plot tab, where you see the last plot generated [bottom right section as tab] the help tab, with useful documentation of R functions [bottom right section as tab] (F1 on the name of a function or Ctrl+3) the history tab, with the list of the R commands used [top right section as tab] the environment tab, with the created variables and functions loaded [top right section as tab] and the packages tab, with the available/loaded R packages [bottom right section as tab] Check the View menu to find out the rest of useful shortcuts! 1.2 First steps with R This section is largely borrowed from the book Introduction to Data Science by Rafael Irizarry. [https://rafalab.github.io/dsbook] 1.2.1 Objects Suppose a high school student asks us for help solving several quadratic equations of the form \\(ax^2+bx+c = 0\\). The quadratic formula gives us the solutions: \\[ \\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\,\\, \\mbox{ and } \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\] which of course change depending on the values of \\(a\\), \\(b\\), and \\(c\\). One advantage of programming languages is that we can define variables and write expressions with these variables, similar to how we do so in math, but obtain a numeric solution. We will write out general code for the quadratic equation below, but if we are asked to solve \\(x^2 + x -1 = 0\\), then we define: a &lt;- 1 b &lt;- 1 c &lt;- -1 which stores the values for later use. We use &lt;- to assign values to the variables. We can also assign values using = instead of &lt;-, but we recommend against using = to avoid confusion. Copy and paste the code above into your console to define the three variables. Note that R does not print anything when we make this assignment. This means the objects were defined successfully. Had you made a mistake, you would have received an error message. To see the value stored in a variable, we simply ask R to evaluate a and it shows the stored value: a ## [1] 1 A more explicit way to ask R to show us the value stored in a is using print like this: print(a) ## [1] 1 We use the term object to describe stuff that is stored in R. 1.2.2 The workspace As we define objects in the console, we are actually changing the workspace. You can see all the variables saved in your workspace by typing: ls() ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; In RStudio, the variables of the environment are displayed in the Environment tab. We should see a, b, and c. If you try to recover the value of a variable that is not in your workspace, you receive an error. For example, if you type x you will receive the following message: Error: object 'x' not found. Now since these values are saved in variables, to obtain a solution to our equation, we use the quadratic formula: (-b + sqrt(b^2 - 4*a*c) ) / ( 2*a ) ## [1] 0.618034 (-b - sqrt(b^2 - 4*a*c) ) / ( 2*a ) ## [1] -1.618034 1.2.3 Functions Once you define variables, the data analysis process can usually be described as a series of functions applied to the data. R includes several predefined functions and most of the analysis pipelines we construct make extensive use of these. We already used the print, and ls functions. We also used the function sqrt to solve the quadratic equation above. There are many more prebuilt functions and even more can be added through packages. These functions do not appear in the workspace because you did not define them, but they are available for immediate use. In general, we need to use parentheses to evaluate a function. If you type ls, the function is not evaluated and instead R shows you the code that defines the function. If you type ls() the function is evaluated and, as seen above, we see objects in the workspace. Unlike ls, most functions require one or more arguments. Below is an example of how we assign an object to the argument of the function log. Remember that we earlier defined a to be 1: log(8) ## [1] 2.079442 log(a) ## [1] 0 You can find out what the function expects and what it does by reviewing the very useful manuals included in R. You can get help by using the help function like this: help(&quot;log&quot;) For most functions, we can also use this shorthand: ?log The help page will show you what arguments the function is expecting. For example, log needs x and base to run. However, some arguments are required and others are optional. You can determine which arguments are optional by noting in the help document that a default value is assigned with =. Defining these is optional. For example, the base of the function log defaults to base = exp(1) making log the natural log by default. If you want a quick look at the arguments without opening the help system, you can type: args(log) ## function (x, base = exp(1)) ## NULL You can change the default values by simply assigning another object: log(8, base = 2) ## [1] 3 Note that we have not been specifying the argument x as such: log(x = 8, base = 2) ## [1] 3 The above code works, but we can save ourselves some typing: if no argument name is used, R assumes you are entering arguments in the order shown in the help file or by args. So by not using the names, it assumes the arguments are x followed by base: log(8,2) ## [1] 3 If using the arguments’ names, then we can include them in whatever order we want: log(base = 2, x = 8) ## [1] 3 To specify arguments, we must use =, and cannot use &lt;-. There are some exceptions to the rule that functions need the parentheses to be evaluated. Among these, the most commonly used are the arithmetic and relational operators. For example: 2 ^ 3 ## [1] 8 You can see the arithmetic operators by typing: help(&quot;+&quot;) or ?&quot;+&quot; and the relational operators by typing: help(&quot;&gt;&quot;) or ?&quot;&gt;&quot; 1.2.4 Other prebuilt objects There are several datasets that are included for users to practice and test out functions. You can see all the available datasets by typing: data() This shows you the object name for these datasets. These datasets are objects that can be used by simply typing the name. For example, if you type: co2 R will show you Mauna Loa atmospheric CO2 concentration data. Other prebuilt objects are mathematical quantities, such as the constant \\(\\pi\\) and \\(\\infty\\): pi ## [1] 3.141593 Inf+1 ## [1] Inf 1.2.5 Variable names We have used the letters a, b, and c as variable names, but variable names can be almost anything. Some basic rules in R are that variable names have to start with a letter, can’t contain spaces, and should not be variables that are predefined in R. For example, don’t name one of your variables install.packages by typing something like install.packages &lt;- 2. A nice convention to follow is to use meaningful words that describe what is stored, use only lower case, and use underscores as a substitute for spaces. For the quadratic equations, we could use something like this: solution_1 &lt;- (-b + sqrt(b^2 - 4*a*c)) / (2*a) solution_2 &lt;- (-b - sqrt(b^2 - 4*a*c)) / (2*a) For more advice, we highly recommend studying Hadley Wickham’s style guide1. 1.2.6 Reusing scripts To solve another equation such as \\(3x^2 + 2x -1\\), we can copy and paste the code above and then redefine the variables and recompute the solution: a &lt;- 3 b &lt;- 2 c &lt;- -1 (-b + sqrt(b^2 - 4*a*c)) / (2*a) (-b - sqrt(b^2 - 4*a*c)) / (2*a) By creating and saving a script with the code above, we would not need to retype everything each time and, instead, simply change the variable names. Try writing the script above into an editor and notice how easy it is to change the variables and receive an answer. 1.2.7 Commenting your code If a line of R code starts with the symbol #, it is not evaluated. We can use this to write reminders of why we wrote particular code. For example, in the script above we could add: ## Code to compute solution to quadratic equation of the form ax^2 + bx + c ## define the variables a &lt;- 3 b &lt;- 2 c &lt;- -1 ## now compute the solution (-b + sqrt(b^2 - 4*a*c)) / (2*a) (-b - sqrt(b^2 - 4*a*c)) / (2*a) 1.3 Data types Variables in R can be of different types. For example, we need to distinguish numbers from character strings and tables from simple lists of numbers. The function class helps us determine what type of object we have: a &lt;- 2 class(a) ## [1] &quot;numeric&quot; To work efficiently in R, it is important to learn the different types of variables and what we can do with these. 1.3.1 Data frames Up to now, the variables we have defined are just one number. This is not very useful for storing data. The most common way of storing a dataset in R is in a data frame. Conceptually, we can think of a data frame as a table with rows representing observations and the different variables reported for each observation defining the columns. Data frames are particularly useful for datasets because we can combine different data types into one object. A large proportion of data analysis challenges start with data stored in a data frame.You can access this dataset by loading the dslabs library and loading the murders dataset using the data function: library(dslabs) data(murders) To see that this is in fact a data frame, we type: class(murders) ## [1] &quot;data.frame&quot; 1.3.2 Examining an object The function str is useful for finding out more about the structure of an object: str(murders) ## &#39;data.frame&#39;: 51 obs. of 5 variables: ## $ state : chr &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... ## $ abb : chr &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; ... ## $ region : Factor w/ 4 levels &quot;Northeast&quot;,&quot;South&quot;,..: 2 4 4 2 4 4 1 2 2 2 ... ## $ population: num 4779736 710231 6392017 2915918 37253956 ... ## $ total : num 135 19 232 93 1257 ... This tells us much more about the object. We see that the table has 51 rows (50 states plus DC) and five variables. We can show the first six lines using the function head: head(murders) ## state abb region population total ## 1 Alabama AL South 4779736 135 ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 ## 4 Arkansas AR South 2915918 93 ## 5 California CA West 37253956 1257 ## 6 Colorado CO West 5029196 65 In this dataset, each state is considered an observation and five variables are reported for each state. Before we go any further in answering our original question about different states, let’s learn more about the components of this object. 1.3.3 The accessor: $ For our analysis, we will need to access the different variables represented by columns included in this data frame. To do this, we use the accessor operator $ in the following way: murders$population ## [1] 4779736 710231 6392017 2915918 37253956 5029196 3574097 897934 601723 19687653 9920000 1360301 ## [13] 1567582 12830632 6483802 3046355 2853118 4339367 4533372 1328361 5773552 6547629 9883640 5303925 ## [25] 2967297 5988927 989415 1826341 2700551 1316470 8791894 2059179 19378102 9535483 672591 11536504 ## [37] 3751351 3831074 12702379 1052567 4625364 814180 6346105 25145561 2763885 625741 8001024 6724540 ## [49] 1852994 5686986 563626 But how did we know to use population? Previously, by applying the function str to the object murders, we revealed the names for each of the five variables stored in this table. We can quickly access the variable names using: names(murders) ## [1] &quot;state&quot; &quot;abb&quot; &quot;region&quot; &quot;population&quot; &quot;total&quot; It is important to know that the order of the entries in murders$population preserves the order of the rows in our data table. Tip: R comes with a very nice auto-complete functionality that saves us the trouble of typing out all the names. Try typing murders$p then hitting the tab key on your keyboard. This functionality and many other useful auto-complete features are available when working in RStudio. 1.3.4 Vectors: numerics, characters, and logical The object murders$population is not one number but several. We call these types of objects vectors. A single number is technically a vector of length 1, but in general we use the term vectors to refer to objects with several entries. The function length tells you how many entries are in the vector: pop &lt;- murders$population length(pop) ## [1] 51 This particular vector is numeric since population sizes are numbers: class(pop) ## [1] &quot;numeric&quot; In a numeric vector, every entry must be a number. To store character strings, vectors can also be of class character. For example, the state names are characters: class(murders$state) ## [1] &quot;character&quot; As with numeric vectors, all entries in a character vector need to be a character. Another important type of vectors are logical vectors. These must be either TRUE or FALSE. z &lt;- 3 == 2 z ## [1] FALSE class(z) ## [1] &quot;logical&quot; Here the == is a relational operator asking if 3 is equal to 2. In R, if you just use one =, you actually assign a variable, but if you use two == you test for equality. You can see the other relational operators by typing: ?Comparison In future sections, you will see how useful relational operators can be. Advanced: Mathematically, the values in pop are integers and there is an integer class in R. However, by default, numbers are assigned class numeric even when they are round integers. For example, class(1) returns numeric. You can turn them into class integer with the as.integer() function or by adding an L like this: 1L. Note the class by typing: class(1L) 1.3.5 Factors In the murders dataset, we might expect the region to also be a character vector. However, it is not: class(murders$region) ## [1] &quot;factor&quot; It is a factor. Factors are useful for storing categorical data. We can see that there are only 4 regions by using the levels function: levels(murders$region) ## [1] &quot;Northeast&quot; &quot;South&quot; &quot;North Central&quot; &quot;West&quot; In the background, R stores these levels as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters. Note that the levels have an order that is different from the order of appearance in the factor object. The default in R is for the levels to follow alphabetical order. However, often we want the levels to follow a different order. You can specify an order through the levels argument when creating the factor with the factor function. For example, in the murders dataset regions are ordered from east to west. The function reorder lets us change the order of the levels of a factor variable based on a summary computed on a numeric vector. We will demonstrate this with a simple example, and will see more advanced ones in the Data Visualization part of the book. Suppose we want the levels of the region by the total number of murders rather than alphabetical order. If there are values associated with each level, we can use the reorder and specify a data summary to determine the order. The following code takes the sum of the total murders in each region, and reorders the factor following these sums. region &lt;- murders$region value &lt;- murders$total region &lt;- reorder(region, value, FUN = sum) levels(region) ## [1] &quot;Northeast&quot; &quot;North Central&quot; &quot;West&quot; &quot;South&quot; The new order is in agreement with the fact that the Northeast has the least murders and the South has the most. Warning: Factors can be a source of confusion since sometimes they behave like characters and sometimes they do not. As a result, confusing factors and characters are a common source of bugs. 1.3.6 Lists Data frames are a special case of lists. Lists are useful because you can store any combination of different types. You can create a list using the list function like this: record &lt;- list(name = &quot;John Doe&quot;, student_id = 1234, grades = c(95, 82, 91, 97, 93), final_grade = &quot;A&quot;) The function c is described in Section 1.4. This list includes a character, a number, a vector with five numbers, and another character. record ## $name ## [1] &quot;John Doe&quot; ## ## $student_id ## [1] 1234 ## ## $grades ## [1] 95 82 91 97 93 ## ## $final_grade ## [1] &quot;A&quot; class(record) ## [1] &quot;list&quot; As with data frames, you can extract the components of a list with the accessor $. record$student_id ## [1] 1234 We can also use double square brackets ([[) like this: record[[&quot;student_id&quot;]] ## [1] 1234 You should get used to the fact that in R, there are often several ways to do the same thing, such as accessing entries. You might also encounter lists without variable names. record2 &lt;- list(&quot;John Doe&quot;, 1234) record2 ## [[1]] ## [1] &quot;John Doe&quot; ## ## [[2]] ## [1] 1234 If a list does not have names, you cannot extract the elements with $, but you can still use the brackets method and instead of providing the variable name, you provide the list index, like this: record2[[1]] ## [1] &quot;John Doe&quot; 1.3.7 Matrices Matrices are another type of object that are common in R. Matrices are similar to data frames in that they are two-dimensional: they have rows and columns. However, like numeric, character and logical vectors, entries in matrices have to be all the same type. For this reason data frames are much more useful for storing data, since we can have characters, factors, and numbers in them. Yet matrices have a major advantage over data frames: we can perform matrix algebra operations, a powerful type of mathematical technique. We do not describe these operations in this book, but much of what happens in the background when you perform a data analysis involves matrices. We can define a matrix using the matrix function. We need to specify the number of rows and columns. mat &lt;- matrix(1:12, 4, 3) mat ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 You can access specific entries in a matrix using square brackets ([). If you want the second row, third column, you use: mat[2, 3] ## [1] 10 If you want the entire second row, you leave the column spot empty: mat[2, ] ## [1] 2 6 10 Notice that this returns a vector, not a matrix. Similarly, if you want the entire third column, you leave the row spot empty: mat[, 3] ## [1] 9 10 11 12 This is also a vector, not a matrix. You can access more than one column or more than one row if you like. This will give you a new matrix. mat[, 2:3] ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 ## [3,] 7 11 ## [4,] 8 12 You can subset both rows and columns: mat[1:2, 2:3] ## [,1] [,2] ## [1,] 5 9 ## [2,] 6 10 We can convert matrices into data frames using the function as.data.frame: as.data.frame(mat) ## V1 V2 V3 ## 1 1 5 9 ## 2 2 6 10 ## 3 3 7 11 ## 4 4 8 12 You can also use single square brackets ([) to access rows and columns of a data frame: data(&quot;murders&quot;) murders[25, 1] ## [1] &quot;Mississippi&quot; murders[2:3, ] ## state abb region population total ## 2 Alaska AK West 710231 19 ## 3 Arizona AZ West 6392017 232 1.4 Vectors In R, the most basic objects available to store data are vectors. As we have seen, complex datasets can usually be broken down into components that are vectors. For example, in a data frame, each column is a vector. Here we learn more about this important class. 1.4.1 Creating vectors We can create vectors using the function c, which stands for concatenate. We use c to concatenate entries in the following way: codes &lt;- c(380, 124, 818) codes ## [1] 380 124 818 We can also create character vectors. We use the quotes to denote that the entries are characters rather than variable names. country &lt;- c(&quot;italy&quot;, &quot;canada&quot;, &quot;egypt&quot;) In R you can also use single quotes: country &lt;- c(&#39;italy&#39;, &#39;canada&#39;, &#39;egypt&#39;) But be careful not to confuse the single quote ’ with the back quote `. By now you should know that if you type: country &lt;- c(italy, canada, egypt) you receive an error because the variables italy, canada, and egypt are not defined. If we do not use the quotes, R looks for variables with those names and returns an error. 1.4.2 Names Sometimes it is useful to name the entries of a vector. For example, when defining a vector of country codes, we can use the names to connect the two: codes &lt;- c(italy = 380, canada = 124, egypt = 818) codes ## italy canada egypt ## 380 124 818 The object codes continues to be a numeric vector: class(codes) ## [1] &quot;numeric&quot; but with names: names(codes) ## [1] &quot;italy&quot; &quot;canada&quot; &quot;egypt&quot; If the use of strings without quotes looks confusing, know that you can use the quotes as well: codes &lt;- c(&quot;italy&quot; = 380, &quot;canada&quot; = 124, &quot;egypt&quot; = 818) codes ## italy canada egypt ## 380 124 818 There is no difference between this function call and the previous one. This is one of the many ways in which R is quirky compared to other languages. We can also assign names using the names functions: codes &lt;- c(380, 124, 818) country &lt;- c(&quot;italy&quot;,&quot;canada&quot;,&quot;egypt&quot;) names(codes) &lt;- country codes ## italy canada egypt ## 380 124 818 1.4.3 Sequences Another useful function for creating vectors generates sequences: seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 The first argument defines the start, and the second defines the end which is included. The default is to go up in increments of 1, but a third argument lets us tell it how much to jump by: seq(1, 10, 2) ## [1] 1 3 5 7 9 If we want consecutive integers, we can use the following shorthand: 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 When we use these functions, R produces integers, not numerics, because they are typically used to index something: class(1:10) ## [1] &quot;integer&quot; However, if we create a sequence including non-integers, the class changes: class(seq(1, 10, 0.5)) ## [1] &quot;numeric&quot; 1.4.4 Subsetting We use square brackets to access specific elements of a vector. For the vector codes we defined above, we can access the second element using: codes[2] ## canada ## 124 You can get more than one entry by using a multi-entry vector as an index: codes[c(1,3)] ## italy egypt ## 380 818 The sequences defined above are particularly useful if we want to access, say, the first two elements: codes[1:2] ## italy canada ## 380 124 If the elements have names, we can also access the entries using these names. Below are two examples. codes[&quot;canada&quot;] ## canada ## 124 codes[c(&quot;egypt&quot;,&quot;italy&quot;)] ## egypt italy ## 818 380 1.5 Coercion In general, coercion is an attempt by R to be flexible with data types. When an entry does not match the expected, some of the prebuilt R functions try to guess what was meant before throwing an error. This can also lead to confusion. Failing to understand coercion can drive programmers crazy when attempting to code in R since it behaves quite differently from most other languages in this regard. Let’s learn about it with some examples. We said that vectors must be all of the same type. So if we try to combine, say, numbers and characters, you might expect an error: x &lt;- c(1, &quot;canada&quot;, 3) But we don’t get one, not even a warning! What happened? Look at x and its class: x ## [1] &quot;1&quot; &quot;canada&quot; &quot;3&quot; class(x) ## [1] &quot;character&quot; R coerced the data into characters. It guessed that because you put a character string in the vector, you meant the 1 and 3 to actually be character strings \"1\" and “3.” The fact that not even a warning is issued is an example of how coercion can cause many unnoticed errors in R. R also offers functions to change from one type to another. For example, you can turn numbers into characters with: x &lt;- 1:5 y &lt;- as.character(x) y ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; You can turn it back with as.numeric: as.numeric(y) ## [1] 1 2 3 4 5 This function is actually quite useful since datasets that include numbers as character strings are common. 1.5.1 Not availables (NA) When a function tries to coerce one type to another and encounters an impossible case, it usually gives us a warning and turns the entry into a special value called an NA for “not available.” For example: x &lt;- c(&quot;1&quot;, &quot;b&quot;, &quot;3&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] 1 NA 3 R does not have any guesses for what number you want when you type b, so it does not try. As a data scientist you will encounter the NAs often as they are generally used for missing data, a common problem in real-world datasets. 1.6 Sorting Now that we have mastered some basic R knowledge, let’s try to gain some insights into the safety of different states in the context of gun murders. 1.6.1 sort Say we want to rank the states from least to most gun murders. The function sort sorts a vector in increasing order. We can therefore see the largest number of gun murders by typing: library(dslabs) data(murders) sort(murders$total) ## [1] 2 4 5 5 7 8 11 12 12 16 19 21 22 27 32 36 38 53 63 65 67 ## [22] 84 93 93 97 97 99 111 116 118 120 135 142 207 219 232 246 250 286 293 310 321 ## [43] 351 364 376 413 457 517 669 805 1257 However, this does not give us information about which states have which murder totals. For example, we don’t know which state had 1257. 1.6.2 order The function order is closer to what we want. It takes a vector as input and returns the vector of indexes that sorts the input vector. This may sound confusing so let’s look at a simple example. We can create a vector and sort it: x &lt;- c(31, 4, 15, 92, 65) sort(x) ## [1] 4 15 31 65 92 Rather than sort the input vector, the function order returns the index that sorts input vector: index &lt;- order(x) x[index] ## [1] 4 15 31 65 92 This is the same output as that returned by sort(x). If we look at this index, we see why it works: x ## [1] 31 4 15 92 65 order(x) ## [1] 2 3 1 5 4 The second entry of x is the smallest, so order(x) starts with 2. The next smallest is the third entry, so the second entry is 3 and so on. How does this help us order the states by murders? First, remember that the entries of vectors you access with $ follow the same order as the rows in the table. For example, these two vectors containing state names and abbreviations, respectively, are matched by their order: murders$state[1:6] ## [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; &quot;California&quot; &quot;Colorado&quot; murders$abb[1:6] ## [1] &quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot; &quot;CA&quot; &quot;CO&quot; This means we can order the state names by their total murders. We first obtain the index that orders the vectors according to murder totals and then index the state names vector: ind &lt;- order(murders$total) murders$abb[ind] ## [1] &quot;VT&quot; &quot;ND&quot; &quot;NH&quot; &quot;WY&quot; &quot;HI&quot; &quot;SD&quot; &quot;ME&quot; &quot;ID&quot; &quot;MT&quot; &quot;RI&quot; &quot;AK&quot; &quot;IA&quot; &quot;UT&quot; &quot;WV&quot; &quot;NE&quot; &quot;OR&quot; &quot;DE&quot; &quot;MN&quot; &quot;KS&quot; &quot;CO&quot; &quot;NM&quot; ## [22] &quot;NV&quot; &quot;AR&quot; &quot;WA&quot; &quot;CT&quot; &quot;WI&quot; &quot;DC&quot; &quot;OK&quot; &quot;KY&quot; &quot;MA&quot; &quot;MS&quot; &quot;AL&quot; &quot;IN&quot; &quot;SC&quot; &quot;TN&quot; &quot;AZ&quot; &quot;NJ&quot; &quot;VA&quot; &quot;NC&quot; &quot;MD&quot; &quot;OH&quot; &quot;MO&quot; ## [43] &quot;LA&quot; &quot;IL&quot; &quot;GA&quot; &quot;MI&quot; &quot;PA&quot; &quot;NY&quot; &quot;FL&quot; &quot;TX&quot; &quot;CA&quot; According to the above, California had the most murders. 1.6.3 max and which.max If we are only interested in the entry with the largest value, we can use max for the value: max(murders$total) ## [1] 1257 and which.max for the index of the largest value: i_max &lt;- which.max(murders$total) murders$state[i_max] ## [1] &quot;California&quot; For the minimum, we can use min and which.min in the same way. Does this mean California is the most dangerous state? In an upcoming section, we argue that we should be considering rates instead of totals. Before doing that, we introduce one last order-related function: rank. 1.6.4 rank Although not as frequently used as order and sort, the function rank is also related to order and can be useful. For any given vector it returns a vector with the rank of the first entry, second entry, etc., of the input vector. Here is a simple example: x &lt;- c(31, 4, 15, 92, 65) rank(x) ## [1] 3 1 2 5 4 1.6.5 Beware of recycling Another common source of unnoticed errors in R is the use of recycling. We saw that vectors are added element-wise. So if the vectors don’t match in length, it is natural to assume that we should get an error. But we don’t. Notice what happens: x &lt;- c(1,2,3) y &lt;- c(10, 20, 30, 40, 50, 60, 70) x+y ## Warning in x + y: longer object length is not a multiple of shorter object length ## [1] 11 22 33 41 52 63 71 We do get a warning, but no error. For the output, R has recycled the numbers in x. Notice the last digit of numbers in the output. 1.7 Vector arithmetics California had the most murders, but does this mean it is the most dangerous state? What if it just has many more people than any other state? We can quickly confirm that California indeed has the largest population: library(dslabs) data(&quot;murders&quot;) murders$state[which.max(murders$population)] ## [1] &quot;California&quot; with over 37 million inhabitants. It is therefore unfair to compare the totals if we are interested in learning how safe the state is. What we really should be computing is the murders per capita (murders per 100,000 as the unit). To compute this quantity, the powerful vector arithmetic capabilities of R come in handy. 1.7.1 Rescaling a vector In R, arithmetic operations on vectors occur element-wise. For a quick example, suppose we have height in inches: inches &lt;- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70) and want to convert to centimeters. Notice what happens when we multiply inches by 2.54: inches * 2.54 ## [1] 175.26 157.48 167.64 177.80 177.80 185.42 170.18 185.42 170.18 177.80 In the line above, we multiplied each element by 2.54. Similarly, if for each entry we want to compute how many inches taller or shorter than 69 inches, the average height for males, we can subtract it from every entry like this: inches - 69 ## [1] 0 -7 -3 1 1 4 -2 4 -2 1 1.7.2 Two vectors If we have two vectors of the same length, and we sum them in R, they will be added entry by entry as follows: \\[ \\begin{pmatrix} a\\\\ b\\\\ c\\\\ d \\end{pmatrix} + \\begin{pmatrix} e\\\\ f\\\\ g\\\\ h \\end{pmatrix} = \\begin{pmatrix} a +e\\\\ b + f\\\\ c + g\\\\ d + h \\end{pmatrix} \\] The same holds for other mathematical operations, such as -, * and /. This implies that to compute the murder rates we can simply type: murder_rate &lt;- murders$total / murders$population * 100000 Once we do this, we notice that California is no longer near the top of the list. In fact, we can use what we have learned to order the states by murder rate: murders$abb[order(murder_rate)] ## [1] &quot;VT&quot; &quot;NH&quot; &quot;HI&quot; &quot;ND&quot; &quot;IA&quot; &quot;ID&quot; &quot;UT&quot; &quot;ME&quot; &quot;WY&quot; &quot;OR&quot; &quot;SD&quot; &quot;MN&quot; &quot;MT&quot; &quot;CO&quot; &quot;WA&quot; &quot;WV&quot; &quot;RI&quot; &quot;WI&quot; &quot;NE&quot; &quot;MA&quot; &quot;IN&quot; ## [22] &quot;KS&quot; &quot;NY&quot; &quot;KY&quot; &quot;AK&quot; &quot;OH&quot; &quot;CT&quot; &quot;NJ&quot; &quot;AL&quot; &quot;IL&quot; &quot;OK&quot; &quot;NC&quot; &quot;NV&quot; &quot;VA&quot; &quot;AR&quot; &quot;TX&quot; &quot;NM&quot; &quot;CA&quot; &quot;FL&quot; &quot;TN&quot; &quot;PA&quot; &quot;AZ&quot; ## [43] &quot;GA&quot; &quot;MS&quot; &quot;MI&quot; &quot;DE&quot; &quot;SC&quot; &quot;MD&quot; &quot;MO&quot; &quot;LA&quot; &quot;DC&quot; 1.8 Indexing R provides a powerful and convenient way of indexing vectors. We can, for example, subset a vector based on properties of another vector. In this section, we continue working with our US murders example, which we can load like this: library(dslabs) data(&quot;murders&quot;) 1.8.1 Subsetting with logicals We have now calculated the murder rate using: murder_rate &lt;- murders$total / murders$population * 100000 Imagine you are moving from Italy where, according to an ABC news report, the murder rate is only 0.71 per 100,000. You would prefer to move to a state with a similar murder rate. Another powerful feature of R is that we can use logicals to index vectors. If we compare a vector to a single number, it actually performs the test for each entry. The following is an example related to the question above: ind &lt;- murder_rate &lt; 0.71 If we instead want to know if a value is less or equal, we can use: ind &lt;- murder_rate &lt;= 0.71 Note that we get back a logical vector with TRUE for each entry smaller than or equal to 0.71. To see which states these are, we can leverage the fact that vectors can be indexed with logicals. murders$state[ind] ## [1] &quot;Hawaii&quot; &quot;Iowa&quot; &quot;New Hampshire&quot; &quot;North Dakota&quot; &quot;Vermont&quot; In order to count how many are TRUE, the function sum returns the sum of the entries of a vector and logical vectors get coerced to numeric with TRUE coded as 1 and FALSE as 0. Thus we can count the states using: sum(ind) ## [1] 5 1.8.2 Logical operators Suppose we like the mountains and we want to move to a safe state in the western region of the country. We want the murder rate to be at most 1. In this case, we want two different things to be true. Here we can use the logical operator and, which in R is represented with &amp;. This operation results in TRUE only when both logicals are TRUE. To see this, consider this example: TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE For our example, we can form two logicals: west &lt;- murders$region == &quot;West&quot; safe &lt;- murder_rate &lt;= 1 and we can use the &amp; to get a vector of logicals that tells us which states satisfy both conditions: ind &lt;- safe &amp; west murders$state[ind] ## [1] &quot;Hawaii&quot; &quot;Idaho&quot; &quot;Oregon&quot; &quot;Utah&quot; &quot;Wyoming&quot; 1.8.3 which Suppose we want to look up California’s murder rate. For this type of operation, it is convenient to convert vectors of logicals into indexes instead of keeping long vectors of logicals. The function which tells us which entries of a logical vector are TRUE. So we can type: ind &lt;- which(murders$state == &quot;California&quot;) murder_rate[ind] ## [1] 3.374138 1.8.4 match If instead of just one state we want to find out the murder rates for several states, say New York, Florida, and Texas, we can use the function match. This function tells us which indexes of a second vector match each of the entries of a first vector: ind &lt;- match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) ind ## [1] 33 10 44 Now we can look at the murder rates: murder_rate[ind] ## [1] 2.667960 3.398069 3.201360 1.8.5 %in% If rather than an index we want a logical that tells us whether or not each element of a first vector is in a second, we can use the function %in%. Let’s imagine you are not sure if Boston, Dakota, and Washington are states. You can find out like this: c(&quot;Boston&quot;, &quot;Dakota&quot;, &quot;Washington&quot;) %in% murders$state ## [1] FALSE FALSE TRUE Note that we will be using %in% often throughout the book. Advanced: There is a connection between match and %in% through which. To see this, notice that the following two lines produce the same index (although in different order): match(c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;), murders$state) ## [1] 33 10 44 which(murders$state%in%c(&quot;New York&quot;, &quot;Florida&quot;, &quot;Texas&quot;)) ## [1] 10 33 44 1.9 R programming We teach R because it greatly facilitates data analysis. By coding in R, we can efficiently perform exploratory data analysis, build data analysis pipelines, and prepare data visualization to communicate results. However, R is not just a data analysis environment but a programming language. Advanced R programmers can develop complex packages and even improve R itself, but we do not cover advanced programming. Nonetheless, in Appendix ??, we introduce three key programming concepts: conditional expressions, for-loops, and functions. These are not just key building blocks for advanced programming, but are sometimes useful during data analysis. http://adv-r.had.co.nz/Style.html↩︎ "],["data-wrangling.html", "Chapter 2 Data wrangling 2.1 Data.tables 2.2 Row subsetting 2.3 Column operations 2.4 The ‘by’ option 2.5 Counting occurences with .N 2.6 Extending tables 2.7 Summary 2.8 Data.table resources", " Chapter 2 Data wrangling Data wrangling refers to the task of processing raw data into useful formats. This Chapter introduces basic data wrangling operations in R using data.tables. 2.1 Data.tables 2.1.1 Overview data.table objects are a modern implementation of tables containing variables stored in columns and observations stored in rows. Base R provides a similar structure called data.frame. However, we will exclusively use data.table in this course because data.frame objects are a lot slower and often a little more complicated to use. A data.table is a memory efficient and faster implementation of data.frame. It is more efficient because it operates on its columns by reference. In contrast modifying a data.frame leads R to copy the entire data.frame. Like a data.frame, each column can have a different type. Unlike a data.frame, it doesn’t have row names. It accepts all data.frame functions to ensure compatibility, but it has a shorter and more flexible syntax. This may be not so straightforward in the beginning but pays off and saves time on two fronts: programming (easier to code, read, debug and maintain) computing (fast and memory efficient) The general basic form of the data.table syntax is: DT[ i, j, by ] # | | | | | -------&gt; grouped by what? | -------&gt; what to do with the columns? ---&gt; on which rows? The way to read this out loud is: “Take DT, subset rows by i, then compute j grouped by by.” We will now describe some basic usage examples expanding on this definition. First of all, let us create and inspect some data.tables to get a first impression. 2.1.2 Creating and loading tables To create a data.table, we just name its columns and populate them. All the columns have to have the same length. If vectors of different lengths are provided upon creation of a data.table, R automatically recycles the values of the shorter vectors. Here is an example: # install.packages(&quot;data.table&quot;) library(data.table) DT &lt;- data.table(x = rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), each = 3), y = c(1, 3, 6), v = 1:9) DT # note how column y was recycled ## x y v ## 1: a 1 1 ## 2: a 3 2 ## 3: a 6 3 ## 4: b 1 4 ## 5: b 3 5 ## 6: b 6 6 ## 7: c 1 7 ## 8: c 3 8 ## 9: c 6 9 If we want to convert any other R object to a data.table, all we have to do is to call the as.data.table() function. This is typically done for data.frame objects. # This way we can for example convert any built-in dataset # coming as a data.frame into a data.table: titanic_dt &lt;- as.data.table(Titanic) class(titanic_dt) ## [1] &quot;data.table&quot; &quot;data.frame&quot; Here you can see that the class function informs us that titanic_dt is both a data.table and a data.frame as data.table inherits from data.frame. Alternatively, we can read files from disk and process them using data.table. The easiest way to do so is to use the function fread(). Here is an example using a subset of the Kaggle flight and airports dataset that is limited to flights going in or to the Los Angeles airport. We refer to the description Kaggle flights and airports challenge for more details [https://www.kaggle.com/tylerx/flights-and-airports-data]. To run the following code, save the comma-separated value file flightsLAX.csv into a local folder of your choice and replace the string \"path_to_file\" with the actual path to your flightsLAX.csv file. For example \"path_to_file\" could be substituted with \"/Users/samantha/mydataviz_folder/extdata\". See Appendix I “Importing data” for more details. flights &lt;- fread(&#39;path_to_file/flightsLAX.csv&#39;) Typing the name of the newly created data.table (flights) in the console displays its first and last rows. We observe that reading the file was successful. flights ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 2336 N3KUAA LAX PBI ## 2: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## 3: 2015 1 1 4 US 2013 N584UW LAX CLT ## 4: 2015 1 1 4 DL 1434 N547US LAX MSP ## 5: 2015 1 1 4 AA 115 N3CTAA LAX MIA ## --- ## 389365: 2015 12 31 4 AA 1538 N866AA LAX MIA ## 389366: 2015 12 31 4 AS 175 N431AS LAX ANC ## 389367: 2015 12 31 4 AS 471 N570AS LAX SEA ## 389368: 2015 12 31 4 AA 219 N3LYAA LAX ORD ## 389369: 2015 12 31 4 B6 688 N657JB LAX BOS ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 2 263 2330 741 ## 2: 15 258 2342 756 ## 3: 44 228 2125 753 ## 4: 35 188 1535 605 ## 5: 103 255 2342 839 ## --- ## 389365: 2357 250 2342 731 ## 389366: 2350 291 2345 400 ## 389367: 2353 132 954 225 ## 389368: 2358 198 1744 544 ## 389369: 2355 272 2611 753 2.1.3 Inspecting tables A first step in any analysis should involve inspecting the data we just read in. This often starts by looking the first and last rows of the table as we did above. The next information we are often interested in is the size of our data set. We can use the following commands to obtain it: ncol(flights) # nrow(flights) for number of rows ## [1] 13 dim(flights) # returns nrow and ncol ## [1] 389369 13 Next, we are often interested in basic statistics on the columns. To obtain this information we can call the summary() function on the table. summary(flights[,1:6]) ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER ## Min. :2015 Min. : 1.000 Min. : 1.0 Min. :1.000 Length:389369 Min. : 1 ## 1st Qu.:2015 1st Qu.: 3.000 1st Qu.: 8.0 1st Qu.:2.000 Class :character 1st Qu.: 501 ## Median :2015 Median : 6.000 Median :16.0 Median :4.000 Mode :character Median :1296 ## Mean :2015 Mean : 6.198 Mean :15.7 Mean :3.934 Mean :1905 ## 3rd Qu.:2015 3rd Qu.: 9.000 3rd Qu.:23.0 3rd Qu.:6.000 3rd Qu.:2617 ## Max. :2015 Max. :12.000 Max. :31.0 Max. :7.000 Max. :6896 This provides us already a lot of information about our data. We can for example see that all data is from 2015 as all values in the YEAR column are 2015. But for categorical data this is not very insightful, as we can see for the AIRLINE column. To investigate categorical columns we can have a look at their unique elements using: flights[, unique(AIRLINE)] ## [1] &quot;AA&quot; &quot;US&quot; &quot;DL&quot; &quot;UA&quot; &quot;OO&quot; &quot;AS&quot; &quot;B6&quot; &quot;NK&quot; &quot;VX&quot; &quot;WN&quot; &quot;HA&quot; &quot;F9&quot; &quot;MQ&quot; This command provided us the airline identifiers present in the dataset. Another valuable information for categorical variables is how often each category occurs. This can be obtained using the following commands: flights[, table(AIRLINE)] ## AIRLINE ## AA AS B6 DL F9 HA MQ NK OO UA US VX WN ## 65483 16144 8216 50343 2770 3112 368 8688 73389 54862 7374 23598 75022 2.2 Row subsetting As mentioned, the general basic form of the data.table syntax is: DT[ i, j, by ] # | | | | | -------&gt; grouped by what? | -------&gt; what to do with the columns? ---&gt; on which rows? Let us first look at the i argument, i.e. row indexing. The parameter i can be any vector of integers, corresponding to the row indices to select, or some logical vectors indicating which rows to select. Here are some typical examples. 2.2.1 Subsetting rows by indices If we want to see the second element of the table, we can do the following: flights[2, ] # Access the 2nd row (also flights[2] or flights[i = 2]) ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 15 258 2342 756 A shorter writing allows leaving out the comma: flights[2] # Access the 2nd row (also flights[2] or flights[i = 2]) ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 15 258 2342 756 For accessing multiple consecutive rows we can use the start:stop syntax as for example: flights[1:3] ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 2336 N3KUAA LAX PBI ## 2: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## 3: 2015 1 1 4 US 2013 N584UW LAX CLT ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 2 263 2330 741 ## 2: 15 258 2342 756 ## 3: 44 228 2125 753 Accessing multiple rows that are not necessarily consecutive can be done by creating an index vector with c(): flights[c(3, 5)] ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 US 2013 N584UW LAX CLT ## 2: 2015 1 1 4 AA 115 N3CTAA LAX MIA ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 44 228 2125 753 ## 2: 103 255 2342 839 2.2.2 Subsetting rows by logical conditions Often, a more useful way to subset rows is using logical conditions, using for i a logical vector. We can create such logical vectors using the following binary operators: == &lt; &gt; != %in% For example, entries of flights operated by “AA” (American Airlines) can be extracted using: flights[AIRLINE == &quot;AA&quot;] ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 2336 N3KUAA LAX PBI ## 2: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## 3: 2015 1 1 4 AA 115 N3CTAA LAX MIA ## 4: 2015 1 1 4 AA 2410 N3BAAA LAX DFW ## 5: 2015 1 1 4 AA 1515 N3HMAA LAX ORD ## --- ## 65479: 2015 12 31 4 AA 1116 N029AA LAX ATL ## 65480: 2015 12 31 4 AA 246 N863AA KOA LAX ## 65481: 2015 12 31 4 AA 1927 N837AW LAX IAD ## 65482: 2015 12 31 4 AA 1538 N866AA LAX MIA ## 65483: 2015 12 31 4 AA 219 N3LYAA LAX ORD ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 2 263 2330 741 ## 2: 15 258 2342 756 ## 3: 103 255 2342 839 ## 4: 600 150 1235 1052 ## 5: 557 202 1744 1139 ## --- ## 65479: 2256 207 1947 553 ## 65480: 2335 272 2504 635 ## 65481: 2346 239 2288 712 ## 65482: 2357 250 2342 731 ## 65483: 2358 198 1744 544 Alternatively, if we are interested in all flights from any destination to the airports in NYC (“JFK” and “LGA”), we can subset the rows using the following command: flights[DESTINATION_AIRPORT %in% c(&quot;LGA&quot;, &quot;JFK&quot;)] ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 B6 24 N923JB LAX JFK ## 2: 2015 1 1 4 DL 476 N196DN LAX JFK ## 3: 2015 1 1 4 AA 118 N788AA LAX JFK ## 4: 2015 1 1 4 VX 404 N621VA LAX JFK ## 5: 2015 1 1 4 UA 275 N598UA LAX JFK ## --- ## 12011: 2015 12 31 4 AA 180 N796AA LAX JFK ## 12012: 2015 12 31 4 B6 524 N934JB LAX JFK ## 12013: 2015 12 31 4 B6 624 N942JB LAX JFK ## 12014: 2015 12 31 4 DL 1262 N394DL LAX JFK ## 12015: 2015 12 31 4 B6 1124 N943JB LAX JFK ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 620 279 2475 1413 ## 2: 650 274 2475 1458 ## 3: 650 268 2475 1436 ## 4: 728 268 2475 1512 ## 5: 806 277 2475 1606 ## --- ## 12011: 1640 259 2475 18 ## 12012: 1645 261 2475 18 ## 12013: 2107 280 2475 513 ## 12014: 2244 256 2475 625 ## 12015: 2349 274 2475 748 Additionally, we can concatenate multiple conditions using the logical OR | or the logical AND &amp; operator. For instance, if we want to inspect all flights departing between 6am and 7am operated by American Airlines we can use the following statement: flights[AIRLINE == &quot;AA&quot; &amp; DEPARTURE_TIME &gt; 600 &amp; DEPARTURE_TIME &lt; 700] ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 1686 N4XXAA LAX STL ## 2: 2015 1 1 4 AA 1361 N3KYAA BNA LAX ## 3: 2015 1 1 4 AA 2420 N3ERAA LAX DFW ## 4: 2015 1 1 4 AA 338 N3DJAA LAX SFO ## 5: 2015 1 1 4 AA 2424 N3DLAA LAX DFW ## --- ## 3820: 2015 12 31 4 AA 169 N787AA SFO LAX ## 3821: 2015 12 31 4 AA 1352 N7CAAA MIA LAX ## 3822: 2015 12 31 4 AA 146 N3MKAA LAX BOS ## 3823: 2015 12 31 4 AA 2453 N869AA LAX DFW ## 3824: 2015 12 31 4 AA 118 N791AA LAX JFK ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME ## 1: 609 183 1592 1134 ## 2: 607 255 1797 847 ## 3: 619 149 1235 1119 ## 4: 644 55 337 803 ## 5: 641 146 1235 1149 ## --- ## 3820: 623 54 337 740 ## 3821: 651 303 2342 913 ## 3822: 650 268 2611 1446 ## 3823: 651 142 1235 1134 ## 3824: 659 272 2475 1505 2.3 Column operations You may have wondered why R correctly runs code such as flights[AIRLINE == \"AA\"] although AIRLINE is not a variable of the environment but a column of the data.table flights. Such a call would not execute properly with a data.frame. The reason is that code entered inside the [] brackets of a data.table is interpreted using the data.table environment. Inside this environment, columns are seen as variables already. This makes the syntax very light and readable for row subsetting as we just saw. It becomes particularly powerful for column operations. We now look at this. Although feasible, it is not advisable to access a column by its number since the ordering or number of columns can easily change. Also, if you have a data set with a large number of columns (e.g. 50), how do you know which one is column 18? Therefore, use the column name instead. Using column names prevents bugs. 2.3.1 Working with columns Accessing columns by name also makes the code more readable: flights[, TAIL_NUMBER] instead of flights[, 7]. flights[1:10, TAIL_NUMBER] # Access column x (also DT$x or DT[j=x]). ## [1] &quot;N3KUAA&quot; &quot;N3HYAA&quot; &quot;N584UW&quot; &quot;N547US&quot; &quot;N3CTAA&quot; &quot;N76517&quot; &quot;N925SW&quot; &quot;N719SK&quot; &quot;N435SW&quot; &quot;N560SW&quot; For accessing a specific cell (i.e. specific column and specific row), we can use the following syntax: flights[4, TAIL_NUMBER] # Access a specific cell. ## [1] &quot;N547US&quot; This command for accessing multiple columns would return a vector: flights[1:2, c(TAIL_NUMBER, ORIGIN_AIRPORT)] ## [1] &quot;N3KUAA&quot; &quot;N3HYAA&quot; &quot;LAX&quot; &quot;LAX&quot; However, when accessing many columns, we probably want to return a data.table instead of a vector. For that, we need to provide R with a list, so we use list(colA, colB) or its simplified version .(colA, colB): flights[1:2, list(TAIL_NUMBER, ORIGIN_AIRPORT)] ## TAIL_NUMBER ORIGIN_AIRPORT ## 1: N3KUAA LAX ## 2: N3HYAA LAX # Same as before. flights[1:2, .(TAIL_NUMBER, ORIGIN_AIRPORT)] ## TAIL_NUMBER ORIGIN_AIRPORT ## 1: N3KUAA LAX ## 2: N3HYAA LAX 2.3.2 Column operations We already saw that inside the [] environment, columns are seen as variables, so we can apply functions to them. # Similar to mean(flights[, AIR_TIME]) flights[, mean(AIR_TIME, na.rm=TRUE)] ## [1] 162.1379 flights[AIRLINE == &quot;OO&quot;, mean(AIR_TIME, na.rm=TRUE)] ## [1] 68.02261 To compute operations in multiple columns, we must provide a list (unless we want the result to be a vector). # Same as flights[, .(mean(AIR_TIME), median(AIR_TIME))] flights[, list(mean(AIR_TIME, na.rm=TRUE), median(AIR_TIME, na.rm=TRUE))] ## V1 V2 ## 1: 162.1379 150 To give meaningful names to the computations from before, we can use the following command: flights[, .(mean_AIR_TIME = mean(AIR_TIME, na.rm=TRUE), median_AIR_TIME = median(AIR_TIME, na.rm=TRUE))] ## mean_AIR_TIME median_AIR_TIME ## 1: 162.1379 150 Any operation can be applied to the columns, just as with variables. This code computes the average speed as the ratio of AIR_TIME over DISTANCE for the 5 first entries of the table flights: flights[1:5,AIR_TIME/DISTANCE] ## [1] 0.1128755 0.1101623 0.1072941 0.1224756 0.1088813 2.3.3 Advanced commands: *apply() over columns The columns of a data.table are exposed as a list to the environment. Therefore functions applying to a list can be applied to them, including those of the *apply family such as sapply()`. For example: sapply(flights, class) # Try the same with lapply ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE ## &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; &quot;character&quot; ## FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT DEPARTURE_TIME ## &quot;integer&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;integer&quot; ## AIR_TIME DISTANCE ARRIVAL_TIME ## &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; # Note that we can access columns stored as variables by setting with=F. # In this case, `colnames(iris_dt)!=&quot;Species&quot;` returns a logical vector and ` # iris_dt` is subsetted by the logical vector # Same as sapply(iris_dt[, 1:4], sum) #sapply(iris_dt[, colnames(iris_dt)!=&quot;Species&quot;, with = F], sum) 2.4 The ‘by’ option The by option allows executing the j command by groups. For example, we can useby = to compute the mean flight time per airline: flights[, .(mean_AIRTIME = mean(AIR_TIME, na.rm=TRUE)), by = AIRLINE] ## AIRLINE mean_AIRTIME ## 1: AA 219.48133 ## 2: US 210.39488 ## 3: DL 207.07201 ## 4: UA 211.62008 ## 5: OO 68.02261 ## 6: AS 141.01870 ## 7: B6 309.79568 ## 8: NK 179.55828 ## 9: VX 185.36374 ## 10: WN 105.19976 ## 11: HA 307.95961 ## 12: F9 159.94041 ## 13: MQ 102.15210 This way we can easily spot that one airline conducts on average shorter flights. Moreover, we can compute the mean and standard deviation of the air time of every airline: flights[, .(mean_AIRTIME = mean(AIR_TIME, na.rm=TRUE), sd_AIR_TIME = sd(AIR_TIME, na.rm=TRUE)), by = AIRLINE] ## AIRLINE mean_AIRTIME sd_AIR_TIME ## 1: AA 219.48133 92.889719 ## 2: US 210.39488 105.224833 ## 3: DL 207.07201 88.908566 ## 4: UA 211.62008 94.832456 ## 5: OO 68.02261 41.065036 ## 6: AS 141.01870 51.806424 ## 7: B6 309.79568 28.457740 ## 8: NK 179.55828 78.194706 ## 9: VX 185.36374 113.504572 ## 10: WN 105.19976 69.257334 ## 11: HA 307.95961 23.905491 ## 12: F9 159.94041 61.412379 ## 13: MQ 102.15210 8.531046 Although we could write flights[i = 5, j = AIRLINE], we usually omit the i = and j = from the syntax, and write flights[5, AIRLINE] instead. However, for clarity we usually include the by = in the syntax. 2.5 Counting occurences with .N The .N is a special in-built variable that counts the number observations within a table. Evaluating .N alone is equal to nrow() of a table. flights[, .N] ## [1] 389369 nrow(flights) ## [1] 389369 But the .N command becomes a lot more powerful when used with grouping or conditioning. We already saw earlier how we can use it to count the number of occurrences of elements in categorical columns. For instance, we can get the number of flights for each airline: flights[, .N, by = &#39;AIRLINE&#39;] ## AIRLINE N ## 1: AA 65483 ## 2: US 7374 ## 3: DL 50343 ## 4: UA 54862 ## 5: OO 73389 ## 6: AS 16144 ## 7: B6 8216 ## 8: NK 8688 ## 9: VX 23598 ## 10: WN 75022 ## 11: HA 3112 ## 12: F9 2770 ## 13: MQ 368 Remembering the data.table definition: “Take DT, subset rows using i, then select or calculate j, grouped by by,” we can build even more powerful statements using all three elements. For example, we can, for each airline, get the number of flights arriving to the airport JFK: flights[DESTINATION_AIRPORT == &quot;JFK&quot;, .N, by = &#39;AIRLINE&#39;] ## AIRLINE N ## 1: B6 2488 ## 2: DL 2546 ## 3: AA 3804 ## 4: VX 1652 ## 5: UA 1525 2.6 Extending tables 2.6.1 Creating new columns (the := command) The := operator updates the data.table we are working in place, so writing DT &lt;- DT[,... := ...] is redundant. This operator, plus all set functions (e.g. setnames for column name renaming, setcolorder for changing the positions in which the columns positioned are inside the DT, etc), change their input by reference. No copy of the object is made, which makes the operation faster and less memory-consuming. As an example, we can add a new column called SPEED (in miles per hour) whose value is the DISTANCE divided by AIR_TIME times 60: flights[, SPEED := DISTANCE / AIR_TIME * 60] head(flights) ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER TAIL_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT ## 1: 2015 1 1 4 AA 2336 N3KUAA LAX PBI ## 2: 2015 1 1 4 AA 258 N3HYAA LAX MIA ## 3: 2015 1 1 4 US 2013 N584UW LAX CLT ## 4: 2015 1 1 4 DL 1434 N547US LAX MSP ## 5: 2015 1 1 4 AA 115 N3CTAA LAX MIA ## 6: 2015 1 1 4 UA 1545 N76517 LAX IAH ## DEPARTURE_TIME AIR_TIME DISTANCE ARRIVAL_TIME SPEED ## 1: 2 263 2330 741 531.5589 ## 2: 15 258 2342 756 544.6512 ## 3: 44 228 2125 753 559.2105 ## 4: 35 188 1535 605 489.8936 ## 5: 103 255 2342 839 551.0588 ## 6: 112 156 1379 607 530.3846 Having computed a new column using the := operator, we can use it for further analyses. For instance, we can compute the average speed, air time and distance for each airline: flights[, .(mean_AIR_TIME = mean(AIR_TIME, na.rm=TRUE), mean_SPEED = mean(SPEED, na.rm=TRUE), mean_DISTANCE = mean(DISTANCE, na.rm=TRUE) ), by=AIRLINE] ## AIRLINE mean_AIR_TIME mean_SPEED mean_DISTANCE ## 1: AA 219.48133 461.2839 1739.2331 ## 2: US 210.39488 452.1641 1658.2581 ## 3: DL 207.07201 466.0330 1656.2165 ## 4: UA 211.62008 464.2928 1693.5504 ## 5: OO 68.02261 349.5549 437.2337 ## 6: AS 141.01870 439.0120 1040.0340 ## 7: B6 309.79568 484.8242 2486.1489 ## 8: NK 179.55828 450.0221 1402.1591 ## 9: VX 185.36374 433.0870 1432.5384 ## 10: WN 105.19976 409.3803 760.2593 ## 11: HA 307.95961 497.3118 2537.8107 ## 12: F9 159.94041 461.0684 1235.6664 ## 13: MQ 102.15210 435.5580 737.0000 Now we can see that the flights by the carrier “OO” are not just shorter, but also slow. This could for example lead us to the hypothesis, that “OO” is a small regional carrier, which operates slower planes. Additionally we can use the := operator to remove columns. If we for example observe that tail numbers are not important for our analysis we can remove them with the following statement: flights[, TAIL_NUMBER := NULL] head(flights) ## YEAR MONTH DAY DAY_OF_WEEK AIRLINE FLIGHT_NUMBER ORIGIN_AIRPORT DESTINATION_AIRPORT DEPARTURE_TIME AIR_TIME ## 1: 2015 1 1 4 AA 2336 LAX PBI 2 263 ## 2: 2015 1 1 4 AA 258 LAX MIA 15 258 ## 3: 2015 1 1 4 US 2013 LAX CLT 44 228 ## 4: 2015 1 1 4 DL 1434 LAX MSP 35 188 ## 5: 2015 1 1 4 AA 115 LAX MIA 103 255 ## 6: 2015 1 1 4 UA 1545 LAX IAH 112 156 ## DISTANCE ARRIVAL_TIME SPEED ## 1: 2330 741 531.5589 ## 2: 2342 756 544.6512 ## 3: 2125 753 559.2105 ## 4: 1535 605 489.8936 ## 5: 2342 839 551.0588 ## 6: 1379 607 530.3846 Here we observe, that the tail numbers are gone from the data.table. 2.6.2 Advanced: Multiple assignments With the following syntax we can assign multiple new columns at once. We the base R dataset iris,2 which we first transform into a data.table. # load the Iris data table iris_dt &lt;- as.data.table(iris) # Add columns with sepal and petal area. Note the syntax of multiple assignment. iris_dt[, `:=` (Sepal.Area = Sepal.Length * Sepal.Width, Petal.Area = Petal.Length * Petal.Width)][1:3] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Area Petal.Area ## 1: 5.1 3.5 1.4 0.2 setosa 17.85 0.28 ## 2: 4.9 3.0 1.4 0.2 setosa 14.70 0.28 ## 3: 4.7 3.2 1.3 0.2 setosa 15.04 0.26 You can also delete columns by using the := command. # Let&#39;s assume setosa flowers are orange, versicolor purple and virginica pink. # Add a column with these colors. iris_dt[Species == &quot;setosa&quot;, color := &quot;orange&quot;] iris_dt[Species == &quot;versicolor&quot;, color := &quot;purple&quot;] iris_dt[Species == &quot;virginica&quot;, color := &quot;pink&quot;] unique(iris_dt[, .(Species, color)]) ## Species color ## 1: setosa orange ## 2: versicolor purple ## 3: virginica pink # We can delete this new column by setting it to NULL iris_dt[, color := NULL] colnames(iris_dt) ## [1] &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; &quot;Sepal.Area&quot; &quot;Petal.Area&quot; 2.6.3 Copying tables What do we mean when we say that data.table modifies columns by reference? It means that no new copy of the object is made in the memory, unless we actually create one using copy(). or_dt &lt;- data.table(a = 1:10, b = 11:20) # No new object is created, both new_dt and or_dt point to the same memory chunk. new_dt &lt;- or_dt new_dt[, ab := a*b] colnames(or_dt) # or_dt was also affected by changes in new_dt ## [1] &quot;a&quot; &quot;b&quot; &quot;ab&quot; or_dt &lt;- data.table(a = 1:10, b = 11:20) copy_dt &lt;- copy(or_dt) # By creating a copy, we have 2 objects in memory copy_dt[, ab := a*b] colnames(or_dt) # Changes in the copy don&#39;t affect the original ## [1] &quot;a&quot; &quot;b&quot; 2.7 Summary By now, you should be able to answer the following questions: How to subset by rows or columns? Remember: DT[i, j, by]. How to add columns? How to make operations with different columns? 2.8 Data.table resources The help page for data.table. https://cran.r-project.org/web/packages/data.table/ https://s3.amazonaws.com/../assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf http://r4ds.had.co.nz/relational-data.html http://adv-r.had.co.nz/Environments.html https://en.wikipedia.org/wiki/Iris_flower_data_set↩︎ "]]
